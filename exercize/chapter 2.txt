//练习题2.58

//判断是否为小端法
int is_little_endian(void)
{
	int n=1;
	unsigned char * p=(unsigned char *)&n;

	return p[0];
}

//练习题2.59

int consistant(int x,int y)
{
	return (x&bias)|(y&~bias);
}

//练习题2.60

//替换某一个字节
unsigned replace_byte(unsigned x,int i,unsigned char b)
{
	unsigned bias=(0xff)<<(i<<3);
	unsigned re=b<<(i<<3);
	return x&~bias|re;
}

//练习题2.61

int judgeA(int i)	//全为1
{
	return !~i;
}

int judgeB(int i)	//全为0
{
	return !i;
}

int judgeC(int i)	//最低位为1
{
	return judgeA(i|~0xff);
}

int judgeD(int i)	//最高位为0
{
	int n=(sizeof(int)-1)<<3;
	return !(i&(0xff<<n));
}

//练习题2.62
//判断是否为算术右移

int is_arithmetic(void)
{
	int n=-1;

	return !(n^(n>>1));
}

//练习题2.63

unsigned sr1(unsigned x,int k)
{
	//perform shift arithmetically
	unsigned xsra=(int)x>>k;
	int n=-1<<(8*sizeof(int)-k);
	return xsra&~n;
}

int sra(int x ,int k)
{
	//perform shift logically
	int xsr1=(unsigned)x>>k;
	int m=-1<<(8*sizeof(int)-k);
	if(x>=0)	//最高位为0
		return xsr1;
	else
		return xsr1|m;
}

//练习题2.64

int any_odd_one(unsigned x)
{
	int n=0x55555555;
	return !(n^(x&n));
}

//练习题2.65

int odd_one(unsigned x)	
{
	x^=x>>16;//分成两部分，相同置0，不同置1
	x^=x>>8;
	x^=x>>4;
	x^=x>>2;
	x^=x>>1;
	x&=0x1;//最后为奇数时最低位为1
	return x;
}

//练习题2.66
//generate mask indicating leftmost 1 in x

int leftmost_one(unsigned x)
{
	x|=x>>1;
	x|=x>>2;
	x|=x>>4;
	x|=x>>8;
	x|=x>>16;	//转换成000...111...
	return x^(x>>1);
}

//练习题2.67

A.k<=w-1
B.int int_size_is_32(void)
{
	int set_msb =1<<31;
	int beyond_msb=set_msb<<1;
	return set_msb&&!beyond_msb;
}

C.int int_size_is_32(void)
{
	int set_msb=1<<15<<15<<1;
	int beyond_msb=set_msb<<1;
	return set_msb&&!beyond_msb;
}

//练习题2.68

int lower_one_mask(int n)
{
	return ~(-1<<(n-1)<<1);//n可以等于32
}

//练习题2.69

unsigned rotate_left(unsigned x,int n)
{
	int w=sizeof(int)<<3;
	unsigned temp=x>>(w-1-n)>>1;//n可以=0
	return x<<n|temp;
}

//练习题2.70

int fits_bits(int x,int n)
{
	x>>=n-1;
	return !(x >> 1) || !~x;//全为零||全为一
}

//练习题2.71

int xbyte(unsigned word,int bytenum)
{
	int size=sizeof(unsigned);
	int left=(size-bytenum-1)<<3;//确定首位符号
	int right=(size-1)<<3;
	int n=(int)word<<left>>right;
}

//练习题2.72

A.overflow
B.
void copy_int(int val, void* buf, int maxbytes) {
  /* compare two signed number, avoid someone set maxbytes a negetive value */
  if (maxbytes >= (int) sizeof(val)) {
    memcpy(buf, (void*)&val, sizeof(val));
  }
}

//练习题2.73

int saturating_add(int x,int y)
{
	int min=INT_MIN;
	int sum=x+y;
	/* 正溢出：x>=0,y>=0,sum<0 */
	int pos_over=!(x&min)&&!(y&min)&&(sum&min);
	/* 负溢出：x<0,y<0,sum>=0 */
	int neg_over=(x&min)&&(y&min)&&!(sum&min);
	/* 用逻辑运算代替条件运算 */
	(pos_over&&(sum=INT_MAX))||(neg_over&&(sum=INT_MIN));
	return sum;
}

//练习题2.74

int tsub_ok(int x,int y)
{
	int sub=x-y;
	if(y==INT_MIN)	//-INT_MIN会溢出
		return 0;	if(x>0&&y<0&&sub<0)
		return 0;
	else if(x<0&&y>0&&sub>=0)
		return 0;
	else
		return 1;
}

//练习题2.75

unsigned unsigned_high_prod(unsigned x,unsigned y)
{
	int w=sizeof(unsigned)<<3;
	int t=signed_high_prod(x,y);
	int xhign=x>>(w-1);
	int yhign=y>>(w-1);
	unsigned mul=t+xhign*y+yhign*x;	//根据公式2.18转换
	return mul;
}

//利用long long计算高w位

int signed_high_prod(int x,int y)
{
	long long mul=(long long)x*y;
	int w=sizeof(int)<<3;
	return mul>>w;
}

//练习题2.76

void *calloc2(size_t nmemb,size_t size)
{
	void *p;

	if(nmemb==0||size==0)
		return NULL;
	size_t bufsize=nmemb*size;2//检查是否溢出
	if(nmemb==bufsize/size)
	{
		p=malloc(bufsize);
		memset(p,0,bufsize);
		return p;
	}
	return NULL;
}

//练习题2.77

A.(x<<4)+x
B.x-(x<<3)
C.(x<<6)-(x<<2)
D.(x<<4)-(x<<7)

//练习题2.78

int divide_power2(int x,int k)
{
	int w=sizeof(int)<<3;
	int bias=(1<<k)-1;
	int is_neg=x>>(w-1);
	(is_neg&&(x+=bias));//判断为负数后加上bias
	return x>>k;
}
